# Concept

TextInputGuard は、「入力中の体験」と「確定時のデータ整合性」を分離することを目的とした入力制御ライブラリです。

単なる入力制限ではなく、入力フロー全体を設計するためのレイヤーとして設計されています。

## なぜ日本向けなのか

日本語入力環境では、IMEによる文字変換、全角数字や全角記号の混在、入力途中の未確定文字列など、英語圏前提の単純な入力制御では扱いきれない特性があります。

特に業務システムでは、

- 全角と半角の混在
- 小数点やマイナス記号の揺れ
- 表示整形（カンマ付き）と送信値の不一致
- IME確定前の不安定な状態

といった問題が頻発します。

TextInputGuard は、こうした日本語環境特有の入力特性を前提として設計されています。

単純な「入力禁止」や「リアルタイム置換」ではなく、
IMEと共存しながら、入力体験とデータ整合性を両立させることを目的としています。

## 基本思想

### 1. 入力中はユーザー体験を優先する

入力中は、できる限り次を守ります。

- キャレット位置を保つ
- IME動作を壊さない
- 強制的な書き換えを最小限にする

過度なリアルタイム補正はUXを損なう可能性があります。
そのため入力中は、

- `normalizeChar`
- `normalizeStructure`
- `validate`

のみに処理を限定します。

### 2. 確定時はデータ整合性を優先する

フォーカスが外れたタイミング（`blur`）で、次を実行します。

- 未完成な値の補正（`fix`）
- 小数丸め
- 先頭ゼロ整理
- 表示整形（`format`）

これにより、入力体験とデータ品質を両立させます。

## フェーズ分離設計

TextInputGuard では処理を5つのフェーズに分けています。

1. `normalizeChar`
2. `normalizeStructure`
3. `validate`
4. `fix`（確定時のみ）
5. `format`（確定時のみ）

この分離により、

- 役割の明確化
- ルールの責務分離
- 将来拡張の容易さ

を実現しています。

各ルールは、どのフェーズに責任を持つかを明確に定義します。

## エラーと入力ブロックの分離

TextInputGuard では「エラー表示」と「入力拒否」を明確に分離しています。

### `ctx.pushError()`

- エラーを記録する
- 入力は許可する
- `invalidClass` 制御などに使用する

### `ctx.requestRevert()`

- 入力を無効化する
- 直前の受理値へ巻き戻す
- 強制的に入力をブロックする

エラーがあることと、入力を拒否することは別の概念です。

## raw値と表示値の分離（swap モード）

`separateValue.mode = "swap"` の場合、

- raw（`hidden` input）… 送信用データ
- display（`text` input）… 表示用データ

を分離します。

`format` フェーズは display のみに適用され、
raw値は常に整形前の値を保持します。

これにより、

- 表示整形と送信データの分離
- フォーマット依存しないAPI連携

を実現します。

## キャレット保持

入力中に `normalizeChar` や `normalizeStructure` によって値が書き換わる場合でも、可能な限りキャレット位置を維持します。

正規化は「左側のみ再評価」することで、自然なカーソル位置を推定します。

## IME対応

- `compositionstart` 中は評価を行わない
- `compositionend` 後に再評価する

IME入力を破壊しない設計を採用しています。

## 設計目標

- 入力体験を壊さない
- データ整合性を守る
- ルール責務を明確に分離する
- 将来的な拡張に耐える

TextInputGuard は単なる入力制限ライブラリではありません。
入力フローそのものを設計するための基盤ライブラリです。
