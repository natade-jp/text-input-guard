# Advanced Guide

このページでは、TextInputGuard の設計思想、内部アーキテクチャ、そしてルール作成者向けの設計指針をまとめています。
通常の利用者は `/api` を参照してください。

## 1. 設計思想

TextInputGuard は、日本語入力環境における構造的な入力課題を整理し、再利用可能な形で解決することを目的としたライブラリです。

単なる入力制限ツールではなく、入力中の体験と確定後のデータ整合性を分離し、入力フロー全体を設計対象とする基盤レイヤーとして設計されています。

### 1.1 日本語入力環境の構造的特性

日本語入力環境には、次のような技術的・歴史的背景があります。

- IME による未確定文字列（composition）の存在
- 全角／半角という表示幅の概念
- Shift_JIS / CP932 (Windows-31J) に代表されるマルチバイト文化の影響
- 固定桁・固定幅を前提とした帳票文化
- バイト長を要件に含むレガシー業務システム

これらは単なるUI上の問題ではなく、文字コード設計と業務設計の積み重ねによって形成された構造です。

英語圏では入力値は原則として ASCII 互換の単純な文字集合を前提とし、多くのシステムは入力値を内部で正規化して吸収します。IMEのON/OFFや文字幅を強く意識する必要はほとんどありません。

一方、日本では次のような問題が日常的に発生します。

- 数値入力欄に全角数字が入力される
- マイナス記号や小数点が複数のUnicodeコードポイントで混在する
- IME変換中に強制書き換えを行うとキャレット位置が破壊される

これらはユーザーの誤操作ではなく、環境に起因する問題です。

### 1.2 開発契機

多くの方は、これらの課題を画面単位で都度実装してきたと考えれます。

しかしその結果、

- 実装が画面ごとに分散する
- 仕様の微妙な差異が発生する
- IME対応の不具合が再発する
- UXとデータ整合性のどちらかが犠牲になる

といった状態が発生していると考えれます。

特に、

- 入力中に値を書き換えることでキャレットが飛ぶ
- IME未確定状態を破壊してしまう
- 表示整形と内部値の同期が崩れる

といった問題は、`pattern` を使用した単純な入力制限や英語圏のライブラリでは解決できませんでした。

これらの課題は個別対応ではなく、構造として整理する必要があると判断しました。

### 1.3 設計原則

TextInputGuard は、上記の構造的課題に対して、次の原則を採用しています。

1. 入力中と確定時を分離する
   入力中はユーザー体験を優先し、最小限の正規化と検証のみを行います。
   確定時（blur）にはデータ整合性を優先します。

2. 表示とデータを分離する
   表示整形（format）と送信値を明確に分離し、UI都合とデータ整合性を切り離します。

3. 正規化は「意味」に寄せる
   文字幅やUnicode差異そのものではなく、「意味として同一か」を基準に吸収します。

4. フェーズを明確に分解する
    - `normalizeChar`
    - `normalizeStructure`
    - `validate`
    - `fix`
    - `format`

    これらを段階的に適用することで、副作用を局所化し、挙動を予測可能にします。

この設計思想は、日本特有の入力環境を前提としたローカル最適化ではありますが、それは文化的主張ではなく、技術的事実に基づく選択です。

TextInputGuard は、日本語入力環境における複雑さを前提とし、その複雑さを構造として整理することを目的としています。

## 2. アーキテクチャ設計

### 2.1 フェーズ分離設計

TextInputGuard では処理を5つのフェーズに分けています。

1. `normalizeChar`
2. `normalizeStructure`
3. `validate`
4. `fix`（確定時のみ）
5. `format`（確定時のみ）

この分離により、

- 文字変換と構造整理を分離
- 判定と補正を分離
- 表示整形と送信値を分離

という責務の明確化を実現しています。

### 2.2 エラーと入力ブロックの分離

「エラー表示」と「入力拒否」は別概念です。

`ctx.pushError()`

- エラーを記録する
- 入力は許可する

`ctx.requestRevert()`

- 入力を無効化する
- 直前の受理値へ巻き戻す

UX設計の自由度を確保するため、この分離を採用しています。

### 2.3 raw値と表示値の分離（swap モード）

`separateValue.mode = "swap"` の場合、

- raw（`hidden` input）… 送信用データ
- display（`text` input）… 表示用データ

を分離します。

`format` は display のみに適用され、raw値は整形前の値を保持します。

### 2.4 キャレット保持

`normalizeChar` や `normalizeStructure` による値変更時でも、可能な限りキャレット位置を維持します。

正規化は左側のみ再評価することで、自然なカーソル推定を行います。

### 2.5 IME対応

- `compositionstart` 中は評価しない
- `compositionend` 後に再評価する

IME入力を破壊しない設計を採用しています。

## 3. ルール設計ガイド

ここからはルール作成者向けの内容です。

### 3.1 ルールの構造

ルールは次のフェーズを任意で実装できます。

- `normalizeChar(value, ctx)`
- `normalizeStructure(value, ctx)`
- `validate(value, ctx)`
- `fix(value, ctx)`
- `format(value, ctx)`

単機能で小さなルールを組み合わせる設計を推奨します。

### 3.2 各フェーズの役割

#### `normalizeChar`

文字単位の正規化を行います。

例

- 全角 → 半角
- 記号統一
- カンマ除去
- 不要文字削除

ここでは入力拒否は行いません。
`ctx.requestRevert()` は使用しません。

#### `normalizeStructure`

値全体の構造を整えます。

例

- `"-"` は先頭のみ
- `"."` は1つのみ

#### `validate`

ルール違反を判定します。

- `ctx.pushError()` … エラー表示のみ
- `ctx.requestRevert()` … 即時ブロック

`requestRevert()` は原則 `validate` 内のみで使用します。

#### `fix`（確定時のみ）

`blur` 時に実行される穏やかな補正です。

例

- `"-"` → `""`
- `"12."` → `"12"`
- `".1"` → `"0.1"`

#### `format`（確定時のみ）

表示専用整形です。

例

- カンマ付与
- 表示形式変換

`swap` モード時は display のみに適用されます。

### 3.3 フェーズ実行順

入力中

1. `normalizeChar`
2. `normalizeStructure`
3. `validate`

確定時（`blur`）

1. `normalizeChar`
2. `normalizeStructure`
3. `validate`
4. `fix`
5. `validate`（再評価）
6. `format`
